# 淋巴细胞识别

使用简单逻辑处理细胞识别问题
* 聚类抽取ROI
* 使用mask抽取ROI区域
* 在处理


```python
from imp import reload
from IPython.display import display, Markdown, Latex, HTML
from tqdm import tqdm
import seaborn as sns
import math
import pandas as pd
import cv2
import matplotlib.pyplot as plt
import numpy as np
from skimage import measure,data,color,io

from scipy.spatial.distance import cdist
import warnings
warnings.filterwarnings('ignore')


def set_style():
    sns.set_style('white')
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False
    plt.rcParams['figure.figsize'] = [10, 10]

    pd.options.display.max_columns = 300
    pd.options.display.max_rows = 1000
    # plt.rcParams['figure.dpi'] = 200
    sns.set_palette('muted')  # 调色板颜色温和
    sns.set_context("notebook", font_scale=1.2, rc={"lines.linewidth": 1})

set_style()
import sys

sys.path.append('../')
from sklearn.cluster import KMeans
from cell_recogination.common import get_sample_area_info
from cell_recogination.recogination import sample_draw_contours,sample_fill_contours
from source.active_shape_models import *
import pickle
```


```python
from source.lymphocyte_recognition import LymphocyteRecognition
from source.common import contour2img
from source.common import kmeans, cnt_seg, kmeans_dst

from scipy.spatial import procrustes

```

## 工具函数

### seg


```python
def seg(cnts, img, source_img , points_num = 400):
    """
    分割
    """
    centers = []
    result_cnts = []
    for cnt in cnts:
        if cv2.contourArea(cnt) == 0:
            continue
        centers.extend(cnt_seg(cnt, img[:, :, 0], points_num = points_num).values)
        result_cnts.extend(water_seg_simple(cnt, img.copy(), source_img, points_num = points_num))
    return result_cnts, centers
```

### cnt_seg


```python
def cnt_seg(cnt, img, points_num=400):
    """
    找细胞核核心
    :param cnt: 目标轮廓块
    :param img: 细胞灰度图，单通道图
    :points_num: 点个数
    :return: 细胞核核心数据框
    """
    x, y, w, h = cv2.boundingRect(cnt)
    cnt_rect = img[y:(y + h), x:(x + w)].copy()
    img_zero = np.zeros_like(cnt_rect)
    img_zero = cv2.drawContours(
        img_zero, [cnt - [x, y]], -1, (255, 255, 255), cv2.FILLED)
    img_target = cv2.bitwise_and(img_zero, cnt_rect)

    points = cv2.findNonZero(img_target)
#     print(len(points))

    if len(points) < points_num:
        k = 1
    else:
        k = round(len(points) / points_num)

    kmeans_model = KMeans(n_clusters=k)
    kmeans_model.fit(points[:, 0, :])
    df = pd.DataFrame(kmeans_model.cluster_centers_)
    df[0] = df[0] + x
    df[1] = df[1] + y
    return df
```

### myplot


```python
def myplot(centers):
    k = len(centers)
    cols = 4
    rows = k // cols
    if k % cols > 0:
        rows = rows + 1
    plt.figure(figsize=(3*cols, 3*rows))

    for i in range(k):
        plt.subplot(rows,cols,i+1)
        color_img = np.zeros((100,100,3),np.uint8)
        color_img[:,:] = centers[i].astype(np.uint8)
        plt.imshow(cv2.cvtColor(color_img, cv2.COLOR_BGR2RGB))
    plt.show()
```

### prepare


```python
def prepare(img):
    """
    准备工作
    roi提取
    """
    k = 4
    __, __, centers = kmeans(img, k)
    target = [67.9703, 34.286343, 89.76845]
    kmeans_model = KMeans(n_clusters=k)
    kmeans_model.fit(centers)
    img_data = img.reshape((-1, 3)).astype(np.float32)
    img_labels = kmeans_model.predict(img_data)

    # 找最近中心
    dist = cdist(kmeans_model.cluster_centers_, np.array([target])).flatten()
    close_cluster = dist.argmin()
    target_img = kmeans_dst(img_labels, kmeans_model.cluster_centers_, img, k=close_cluster)
    target_gray = cv2.cvtColor(target_img, cv2.COLOR_RGB2GRAY)

    # 找轮廓
    contours, __ = cv2.findContours(target_gray, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    df_info = get_sample_area_info(contours)
    result_contours = [contours[i] for i in df_info[df_info.area > 100].index]
    return result_contours
```

### water_seg_simple


```python
def water_seg_simple(cnt, img, source_img, points_num = 400):
    """
    :param cnt:轮廓信息
    :param img:三通道图,目标图
    :param source_img: 原始图像, 三通道
    """
    img_zero = np.zeros_like(source_img)
    mask = sample_fill_contours([cnt], img_zero)
    mask = cv2.bitwise_and(mask, img)
    
    roi = cv2.bitwise_and(mask, source_img)

    df_centers = cnt_seg(cnt, img[:,:,1], points_num = points_num)

    roi_copy = roi.copy()
    for i in range(len(df_centers)):
        cv2.circle(roi_copy, tuple(
            df_centers.values[i].astype(int)), 1, (0, 255, 255), 2)

#     center_dist = cdist(df_centers.values, df_centers.values)

    # 确定前景点
    fig_points = df_centers.values.astype(int)

    fg = np.zeros_like(roi)
    for i in range(len(fig_points)):
        cv2.circle(fg, tuple(fig_points[i]), 1, (255, 255, 255), 2)

    # 生成markers
    ret, markers = cv2.connectedComponents(fg[:, :, 1])
    markers = markers+1

    # 找到背景
    kernel = np.ones((3, 3))
    bg = sample_fill_contours([cnt], roi)

    opening = cv2.morphologyEx(bg, cv2.MORPH_OPEN, kernel, iterations=2)
    # sure background area
    bg = cv2.dilate(opening, kernel, iterations=3)

    unknown = cv2.subtract(bg, fg)
    markers[unknown[:, :, 1] == 255] = 0

    markers = cv2.watershed(roi, markers)


    img_draw = np.zeros_like(markers).astype(np.uint8)
    img_draw[markers == -1] = 255
    
    
    water_contours, hierarchy = cv2.findContours(
        img_draw, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
    df_waterarea = get_sample_area_info(water_contours)

    df_hierarchy = pd.DataFrame(hierarchy[0])
    df_waterarea = df_waterarea[~pd.Series(
        df_waterarea.index).isin(df_hierarchy[3])]
    df_waterarea = df_waterarea[df_waterarea['area'] < 2000]
    
    result_contours = [water_contours[i] for i in df_waterarea.index]
    
    return result_contours
```

## 准备工作

### load image


```python
image = '/share/pathology/1010/13-COPD-F-003-1.png'
# image = '/share/pathology/200x200/img_0_3.jpg'
img = cv2.imread(image)
```


```python
# sift = cv.SIFT_create()
# gray = img[:,:,1]
# kp, des = sift.detectAndCompute(gray,None)
# img_sift=cv.drawKeypoints(gray,kp,img,flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)


# # plt.figure(figsize=(20,20))
# plt.imshow(img_sift)
```


```python
plt.figure(figsize=(30,30))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
```




    <matplotlib.image.AxesImage at 0x7f1532707908>




![png](output_18_1.png)


## 聚类


```python
k = 4
_, labels, centers = kmeans(img, k)
target = [67.9703, 34.286343, 89.76845]
kmeans_model = KMeans(n_clusters=k)
```


```python
centers
```




    array([[151.78017 ,  73.56377 , 161.6297  ],
           [220.56728 , 208.37459 , 224.91039 ],
           [104.658066,  40.644596,  86.29047 ],
           [182.521   , 113.80223 , 207.11961 ]], dtype=float32)




```python
# 每一类的包含的信息
img_set = []
for i in range(k):
    img_set.append(kmeans_dst(labels, centers, img, k = i))

plt.figure(figsize=(4*20,4*10))
for index,i in enumerate(img_set):
    plt.subplot(4,4,index+1)
    plt.imshow(cv2.cvtColor(i, cv2.COLOR_BGR2RGB))
#     plt.imshow(i)
```


![png](output_22_0.png)



```python
# 每一类的颜色
myplot(centers)
```


![png](output_23_0.png)



```python
# 根据聚类结果筛选出最佳聚类图层
dist = cdist(centers, np.array([target])).flatten()
close_cluster_index = dist.argmin()
target_img = kmeans_dst(labels, centers, img, k = close_cluster_index)
print('close_cluster_index: %d'%close_cluster_index)
plt.figure(figsize=(30,20))
plt.imshow(cv2.cvtColor(target_img, cv2.COLOR_BGR2RGB))
```

    close_cluster_index: 2





    <matplotlib.image.AxesImage at 0x7f15205784a8>




![png](output_24_2.png)



```python
# 找轮廓
contours, __ = cv2.findContours(target_img[:,:,1], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
df_info = get_sample_area_info(contours)
cnts = [contours[i] for i in df_info[df_info.area > 100].index]

plt.figure(figsize=(40,40))
plt.imshow(sample_fill_contours(cnts, img.copy()))
```




    <matplotlib.image.AxesImage at 0x7f152056f0f0>




![png](output_25_1.png)



```python
plt.figure(figsize = (40,40))
plt.imshow(sample_draw_contours(contours, img.copy(), line_width = 1, show_text = False, color = (255,255,255)))
```




    <matplotlib.image.AxesImage at 0x7f15204e5128>




![png](output_26_1.png)


### 分水岭


```python
# 递归分水岭分割，直到没有需要分割的区域停止
cut_cnts = cnts.copy()
centers = None
for i in range(100):
    result_cnts, centers = seg(cut_cnts,target_img, img)
    print('%4d, result_cnts_num: %d, cut_cnts_num: %d'%(i, len(result_cnts), len(cut_cnts)))
    if len(result_cnts) - len(cut_cnts) < 3:
        break
    cut_cnts = result_cnts
```

       0, result_cnts_num: 1908, cut_cnts_num: 796
       1, result_cnts_num: 2018, cut_cnts_num: 1908
       2, result_cnts_num: 2007, cut_cnts_num: 2018



```python
result1_img = img.copy()
for i in range(len(centers)):
    cv2.circle(result1_img,tuple(centers[i].astype(int)),2,(255,255,0),2)
    
    
plt.figure(figsize=(40,40))
plt.imshow(result1_img)
plt.show()
```


![png](output_29_0.png)



```python
plt.figure(figsize = (40,40))
plt.imshow(sample_draw_contours(result_cnts, img.copy(), line_width = 1, show_text = False, color = (255,255,255)))
```




    <matplotlib.image.AxesImage at 0x7f15331a2dd8>




![png](output_30_1.png)



```python
# 形态学操作
mor_cnts = []
for cnt in result_cnts:
    img_cnt = sample_fill_contours([cnt], img)
    img_cnt = cv2.morphologyEx(img_cnt, cv2.MORPH_OPEN,kernel=np.ones((3,3)), iterations = 3)
    img_cnt1 = cv2.dilate(img_cnt, kernel = np.ones((3,3)), iterations = 2)
    
    m_cnts, _ = cv2.findContours(img_cnt1[:,:,1], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    if len(m_cnts) == 0:
        mor_cnts.append(cnt)
        continue
    mor_cnts.append(m_cnts[0])
```


```python
plt.figure(figsize = (40,40))
plt.imshow(sample_draw_contours(mor_cnts, img.copy(), line_width = 1, show_text = False, color = (255,255,255)))
```




    <matplotlib.image.AxesImage at 0x7f152035a2e8>




![png](output_32_1.png)



```python

```


```python

```

## 集成


```python
target = [67.9703, 34.286343, 89.76845]
k = 4
def cell_recogination(img,k,target,min_area):
    """
    淋巴细胞识别
    :param img:输入图像
    :param k:聚类个数
    :param target:
    :param min_area: 轮廓的最小面积，用于滤波
    """
    print("聚类")
    _, labels, centers = kmeans(img, k)
    kmeans_model = KMeans(n_clusters=k)
    
    # 每一类的包含的信息展示
    print('每一类包含的信息展示')
    img_set = []
    for i in range(k):
        img_set.append(kmeans_dst(labels, centers, img, k = i))

    plt.figure(figsize=(4*20,4*10))
    for index,i in enumerate(img_set):
        plt.subplot(4,4,index+1)
        plt.imshow(cv2.cvtColor(i, cv2.COLOR_BGR2RGB))
    plt.show()

    # 根据聚类结果筛选出最佳聚类图层
    print('根据聚类结果筛选出最佳聚类图层')
    dist = cdist(centers, np.array([target])).flatten()
    close_cluster_index = dist.argmin()
    target_img = kmeans_dst(labels, centers, img, k = close_cluster_index)
    print('close_cluster_index: %d'%close_cluster_index)
    plt.figure(figsize=(30,20))
    plt.imshow(cv2.cvtColor(target_img, cv2.COLOR_BGR2RGB))
    plt.show()
    
    # 找轮廓
    print("根据图层找轮廓")
    contours, __ = cv2.findContours(target_img[:,:,1], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    df_info = get_sample_area_info(contours)
    cnts = [contours[i] for i in df_info[df_info.area > min_area].index]

    plt.figure(figsize=(40,40))
    plt.imshow(sample_fill_contours(cnts, img.copy()))
    plt.show()
    
    
    print("递归分水岭分割")
    # 递归分水岭分割，直到没有需要分割的区域停止
    cut_cnts = cnts.copy()
    centers = None
    for i in range(100):
        result_cnts, centers = seg(cut_cnts,target_img, img)
        print('%4d, result_cnts_num: %d, cut_cnts_num: %d'%(i, len(result_cnts), len(cut_cnts)))
        if len(result_cnts) - len(cut_cnts) < 3:
            break
        cut_cnts = result_cnts

    result1_img = img.copy()
    for i in range(len(centers)):
        cv2.circle(result1_img,tuple(centers[i].astype(int)),2,(255,255,0),2)


    plt.figure(figsize=(40,40))
    plt.imshow(result1_img)
    plt.show()
```

### k = 4


```python
cell_recogination(img, k = 4, target=[67.9703, 34.286343, 89.76845], min_area=400)
```

    聚类
    每一类包含的信息展示



![png](output_38_1.png)


    根据聚类结果筛选出最佳聚类图层
    close_cluster_index: 3



![png](output_38_3.png)


    根据图层找轮廓



![png](output_38_5.png)


    递归分水岭分割


### k = 6


```python

```

### k = 8


```python

```
